#!/bin/bash

: <<'TetrisDoc'
    @Param      bool    1
        True if script is to be run in terminal mode
    @Param      bool    2
        True if script is to be run in debug mode
TetrisDoc

extrap()
{
    stty echo
    tput cvvis
}
trap extrap EXIT

[ -z "$1" ] && exit 1

# If game is loaded on a terminal outside of a GUI environment
if $1; then
    _inTTY=true
else
    if [ -z "$DISPLAY" ] || [[ "$TERM" == "linux" ]]; then
        _inTTY=true
    fi
    _inTTY=false
fi

logDir=/var/games/tetris
# Debug mode sends STDERR to an error file
if $2; then
    export PS4='+(${LINENO}) ${FUNCNAME[0]}(): '
    exec 2>~/debug.log
    set -x
else
    exec 2>$logDir/error.log
fi

stty -echo  # Disable echo
tput civis  # Disable cursor blinker

hsLog="$logDir/highscores.ths"
touch "$hsLog" # Create score log if doesn't exist
libDir="/usr/local/lib/tetris"

assetPath='Assets/'

for asset in ${assetPath}*; do
    source "$asset"
done

_state=0
_level=0
_score=0
_lines=0
_currentPiece=
_nextPiece=
_rotation=0

movePiece()
{
    removePiece "$_currentPiece" $pieceY $pieceX

    case $direction in
        'D')    (( pieceY++ ));;
        'R')    (( pieceX += 2 ));;
        'L')    (( pieceX -= 2 ));;
    esac

    renderPiece "$_currentPiece" $pieceY $pieceX
}

rotatePiece()
{
    removePiece "$_currentPiece" $pieceY $pieceX

    (( _rotation == 3 ? _rotation = 0 : _rotation++ ))

    renderPiece "$_currentPiece" $pieceY $pieceX
}

gameLoop()
{
    local                       \
        direction               \
        key1                    \
        key2                    \
        key3                    \
        updatePosition=false    \
        newPiece=true           \
        pieceX                  \
        pieceY                  \
        postTime                \
        preTime                 \
        readPid                 \
        speed                   \
        tick                    \
        timeTaken=0

    while true; do
        # if (( $_lines % 10 == 0 )); then
        #     levelUp
        #     # Lower numer means faster speed
            (( speed = 90 - $_level * 2 ))
        #     (( $speed < 12 )) && speed=12
        # fi
        if $newPiece; then
            [ -n "$_nextPiece" ] && _currentPiece=$_nextPiece || _currentPiece=${pieces[$(( $RANDOM % ${#pieces[@]} ))]}
            _nextPiece=${pieces[$(( $RANDOM % ${#pieces[@]} ))]}

            # Starting geometry for new pieces
            _rotation=0
            pieceY=2
            pieceX=8
            renderPiece "$_currentPiece" $pieceY $pieceX
            renderNextPiece
            newPiece=false
        fi

        if $updatePosition; then
            movePiece
            updatePosition=false
        fi

        preTime=$( date '+%2N' | sed 's/^0//' )
        (( tick = $speed - $timeTaken ))

        # Read STDIN with the timeout relative to the speed
        IFS= read -rsn1 -t0.$(( $tick < 0 ? 0 : $tick )) key1
        readPid=$?
        IFS= read -rsn1 -t0.0001 key2
        IFS= read -rsn1 -t0.0001 key3

        # If read timeout was interrupted
        if (( $readPid != 142 )); then
            # If enter or space is pressed
            if [ -z "$key1" ] || [[ "$key1" == " " ]]; then
                rotatePiece
            # If escape character is pressed
            elif [[ "$key1" == $'\e' ]]; then
                if [ -z "$key2" ]; then
                    pause
                else
                    updatePosition=true
                    case $key3 in
                        B)  direction='D';; # Down
                        C)  direction='R';; # Right
                        D)  direction='L';; # Left
                    esac
                fi
            fi
        fi
        postTime=$( date '+%2N' | sed 's/^0//' )

        (( $postTime < $preTime )) && (( postTime += 100 ))
        if (( $timeTaken )); then
            (( timeTaken += $postTime - $preTime ))
        else
            (( timeTaken = $postTime - $preTime ))
        fi

        if (( $timeTaken >= $speed )); then
            updatePosition=true
            direction='D'
            timeTaken=0
        fi
        unset key1 key2 key3
    done
}

# Set blank global variables to allow restarting
newGame()
{
    _level=0
    _score=0

    # scoreModifier false
    gameLoop
    return $?
}

while true; do
    case $_state in
        *)  renderScreen;;&
        1)  newGame;;
        2)  ;;
        3)  ;;
    esac
done
